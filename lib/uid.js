// Generated by CoffeeScript 1.6.3
(function() {
  var InvalidUidError, Uid, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("underscore");

  InvalidUidError = (function(_super) {
    __extends(InvalidUidError, _super);

    InvalidUidError.prototype.name = 'InvalidUidError';

    function InvalidUidError(message) {
      this.message = message;
    }

    return InvalidUidError;

  })(Error);

  Uid = (function() {
    function Uid(klass, path, oid) {
      var extract_realm, parse_klass, parse_oid, parse_path;
      if (arguments.length === 1 && typeof arguments[0] === 'string') {
        return Uid.fromString(arguments[0]);
      }
      parse_klass = function(value) {
        if (!value) {
          return null;
        }
        if (!Uid.valid_klass(value)) {
          throw new InvalidUidError("Invalid klass '" + value + "'");
        }
        return value;
      };
      parse_path = function(value) {
        if (!value) {
          return null;
        }
        if (!Uid.valid_path(value)) {
          throw new InvalidUidError("Invalid path '" + value + "'");
        }
        return value.trim() || null;
      };
      extract_realm = function(path) {
        if (path) {
          return path.split(".")[0];
        }
      };
      parse_oid = function(value) {
        if (!value) {
          return null;
        }
        if (!Uid.valid_oid(value)) {
          throw new InvalidUidError("Invalid oid '" + value + "'");
        }
        return value.trim() || null;
      };
      this.klass = parse_klass(klass);
      this.path = parse_path(path);
      this.oid = parse_oid(oid);
      this.realm = extract_realm(path);
      if (!this.klass) {
        throw new InvalidUidError("Missing klass in uid");
      }
      if (!(this.path || this.oid)) {
        throw new InvalidUidError("A valid uid must specify either path or oid");
      }
    }

    Uid.prototype.clone = function() {
      return new Uid(this.klass, this.path, this.oid);
    };

    Uid.prototype.toString = function() {
      return "" + this.klass + ":" + (this.path || '') + ((this.oid ? '$' + this.oid : void 0) || '');
    };

    Uid.prototype.parent = function(parentKlass) {
      var i, label, labels, path, _i, _len;
      labels = this.path.split('.');
      path = '';
      for (i = _i = 0, _len = labels.length; _i < _len; i = ++_i) {
        label = labels[i];
        if (i === labels.length - 1) {
          path = "" + path + "$" + label;
        } else if (i === 0) {
          path = label;
        } else {
          path = "" + path + "." + label;
        }
      }
      return "" + (parentKlass || this.klass) + ":" + path;
    };

    Uid.prototype.childPath = function() {
      return "" + this.path + "." + this.oid;
    };

    Uid.prototype.children = function(childKlass) {
      return "" + (childKlass || '*') + ":" + (this.childPath());
    };

    return Uid;

  })();

  _.extend(Uid, {
    fromString: function(string) {
      var klass, oid, path, _ref;
      _ref = Uid.raw_parse(string), klass = _ref[0], path = _ref[1], oid = _ref[2];
      return new Uid(klass, path, oid);
    },
    raw_parse: function(string) {
      var klass, match, oid, path, re, _ref;
      re = /((.*)^[^:]+)?\:([^\$]*)?\$?(.*$)?/;
      if (!(match = string.match(re))) {
        return [];
      }
      return _ref = [match[1], match[3], match[4]], klass = _ref[0], path = _ref[1], oid = _ref[2], _ref;
    },
    valid: function(string) {
      try {
        if (new Uid(string)) {
          return true;
        }
      } catch (_error) {
        InvalidUidError = _error;
        return false;
      }
    },
    parse: function(string) {
      var uid;
      uid = new Uid(string);
      return [uid.klass, uid.path, uid.oid];
    },
    valid_label: function(value) {
      return value.match(/^[a-zA-Z0-9_-]+$/);
    },
    valid_klass: function(value) {
      var label, _i, _len, _ref;
      if (value.match(/^\./)) {
        return false;
      }
      if (value === "") {
        return false;
      }
      _ref = value.split('.');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        label = _ref[_i];
        if (!Uid.valid_label(label)) {
          return false;
        }
      }
      return true;
    },
    valid_path: function(value) {
      var label, _i, _len, _ref;
      if (value === '') {
        return true;
      }
      _ref = value.split('.');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        label = _ref[_i];
        if (!Uid.valid_label(label)) {
          return false;
        }
      }
      return true;
    },
    valid_oid: function(value) {
      return value !== null && value.indexOf('/') === -1;
    }
  });

  exports.Uid = Uid;

}).call(this);
